<!DOCTYPE html>
<html>

	<head>
		<meta charset="utf-8" />
		<title>面试题</title>
		<link rel="stylesheet" href="css/bootstrap.css" />
		<link rel="stylesheet" href="css/mianshi.css" />
	</head>

	<body>
		<script type="text/javascript" src="js/jquery-2.1.1.min.js"></script>
		<script type="text/javascript" src="js/bootstrap.js"></script>
		<div class="container">
			<div>
				<!--头部-->
				<div class="head">
					<h1>高级前端工程师面试题</h1>
				</div>
				<!--头部End-->
			</div>
			<!--正文-->
			<div class="row">
				<div class="col-xs-12 col-md-9 main">
					<div class="all" id="animation">
						<div id="JavaScript">
							<h2>JavaScript</h2>
							<ol>
								<li>
									<h3>JavaScript原型，原型链 ? 有什么特点？</h3>
									<p>
										每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时， 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype， 于是就这样一直找下去，也就是我们平时所说的原型链的概念。 关系：instance.constructor.prototype = instance.__proto__
									</p>
								</li>
								<li>
									<h3>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</h3>
									<p>
										栈：原始数据类型（Undefined，Null，Boolean，Number、String） 堆：引用数据类型（对象、数组和函数） 两种类型的区别是：存储位置不同； 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其 在栈中的地址，取得地址后从堆中获得实体
										<img src="img/1.gif" />
								</li>
								<li>
									<h3>Javascript如何实现继承？</h3>
									<p>•构造继承。
										<br/> •原型继承。
										<br/> •实例继承。
										<br/> •拷贝继承。
										<br />（链接:）
									</p>
								</li>
								<li>
									<h3>javascript创建对象的几种方式？</h3>
									<p>
										javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。
										<pre>
									       1、对象字面量的方式  
   										   <br/>person={firstname:"Mark",lastname:"Yun",age:25,eyecolor:"black"};
									       <br/>2、用function来模拟无参的构造函数 
										   <br/>function Person(){}
											    <br/>var person=new Person();//定义一个function，如果使用new"实例化",该function可以看作是一个Class
											    <br/>person.name="Mark";
											    <br/>person.age="25";
											    <br/>person.work=function(){
											    <br/>alert(person.name+" hello...");
										    <br/>}
											<br/>person.work();
											<br/>3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）
										    <br/>function Pet(name,age,hobby){
										    <br/>this.name=name;//this作用域：当前对象
										    <br/>this.age=age;
										    <br/>this.hobby=hobby;
										    <br/>this.eat=function(){
										    <br/>alert("我叫"+this.name+",我喜欢"+this.hobby+",是个程序员");
										    <br/>}
										    <br/>}
										    <br/>var maidou =new Pet("麦兜",25,"coding");//实例化、创建对象
										    <br/>maidou.eat();//调用eat方法
											<br/>4、用工厂方式来创建（内置对象）
											<br/>var wcDog =new Object();
											<br/>wcDog.name="旺财";
											<br/>wcDog.age=3;
											<br/>wcDog.work=function(){
											<br/>alert("我是"+wcDog.name+",汪汪汪......");
											<br/>}
											<br/>wcDog.work();
											<br/>5、用原型方式来创建
											<br/>function Dog(){
											<br/>}
											<br/>Dog.prototype.name="旺财";
											<br/>Dog.prototype.eat=function(){
											<br/>alert(this.name+"是个吃货");
											<br/>}
											<br/>var wangcai =new Dog();
											<br/>wangcai.eat();
										</pre>
									</p>
								</li>
								<li>
									<h3>Javascript作用链域?</h3>
									<p>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。
									      当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，
									      直至全局函数，这种组织形式就是作用域链。
									</p>
								</li>
								<li>
									<h3>eval是做什么的？</h3>
									<p>它的功能是把对应的字符串解析成JS代码并运行；
							                      应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。
									</p>
								</li>
								<li>
									<h3>谈谈This对象的理解。</h3>
									<p>
										this 指的是引用些函数的对象。
										Javascript一共有四种调用模式：方法调用模式、函数调用模式、构造器调用模式以及apply调用模式。调用模式不同，对应的隐藏参数this值也会不同。
										一.方法调用模式
										函数作为对象的属性时，称为方法。此时函数（即方法）中的this对应是该对象。
										<pre>
										<br/>var myObject = {
										<br/>value:3,
										<br/>func:function(){
										<br/>alert(this.value);
										<br/>}
										<br/>};
										//　方法调用模式，this对应的是myObject对象
										<br/>myObject.func();　　//3
										<br/>也可以写成如下格式：
										<br/>var myObject = {
										<br/>value:3
										<br/>};
										<br/>myObject.func = function() {
										<br/>alert(this.value);
										<br/>}
										<br/>// 方法调用模式
										<br/>myObject.func();　　//3
										</pre>
										<br/>上面，this对应的是myObject对象。
										<br/>二.函数调用模式
										函数调用模式即通常的函数调用，属于全局性调用，此时this对应的是全局对象，即Window对象。
										<pre>
										var add = function(a, b) {
										    return a + b;
										}
										// 函数调用模式
										add(3,4);    //7
										　　上面也可以写成window.add = function(a, b) {
										    return a + b;
										}
										// 函数调用模式
										add(3,4); //7
										　　下面来看看下面的测试题，以检验你是否了解了this。
										   var add = function(a, b) {
										        return a + b;
										    }
										    var myObject = {
										        value:3  
										    };
									    myObject.func = function() {
									        var helper = function() {
									            this.value = add(this.value, this.value); 
									        }
									　　　　// 函数调用模式
									    　　helper();
									    }
									　　// 方法调用模式
									　　 myObject.func();
									    alert(myObject.value);
										</pre>
										<br/>答案会是6吗？仔细想想。
　　										<br/>答案为6的程序应该是这样的：
										<pre>
											    var add = function(a, b) {
											        return a + b;
											    }
											    var myObject = {
											        value:3
											    };
											    myObject.func = function() {
											        var that = this; // this对应myObject对象   （1）
											        var helper = function() {
											            //this.value = add(this.value, this.value); //这里调用模式为函数调用模式，而非方法调用模式，所以this对应全局对象   （2）
											            that.value = add(that.value, that.value);
											        }
											　　　　// 函数调用模式
											    　　helper();
											    }
											　　// 方法调用模式   
											　　 myObject.func();
											    alert(myObject.value);
										</pre>
										三.构造器调用模式　　
										若在函数前面通过new 来调用，其实是生成一新对象，this自然指向该新对象。
										<pre>
										var add = function(a, b) {
										    return a + b;
										}
										
										// 构造器调用模式
										var obj = new add(3, 4);
										obj为一对象：
										对于构造器调用模式，如果函数返回值不是一个对象，则返回该新对象，即this。
										</pre>　　
									四.apply调用模式　　
										apply方法有两个参数，第一个是要绑定给this的值，第二个是一个参数数组。// apply调用模式
										<pre>
										var sum = add.apply(null,[3,4]);       // this对应全局变量，即window对象
										var sum2 = add.apply(myObject,[3,4]);  //this对应为myObject对象
										</pre>
									</p>
								</li>
								<li>
									<h3>eval是做什么的？</h3>
									<p>
										它的功能是把对应的字符串解析成JS代码并运行；
										应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。
									</p>
								</li>
								<li>
									<h3>什么是window对象? 什么是document对象?</h3>
									<p>
										document对象是window和frames对象的一个属性,是显示于窗口或框架内的一个文档。
										window对象它是一个顶层对象,而不是另一个对象的属性即浏览器的窗口。
									</p>
								</li>
								<li>
									<h3>null，undefined 的区别？</h3>
									<p>
										null表示一个对象被定义了，值为“空值”；
										undefined表示不存在这个值。
										<pre>
											typeof undefined//"undefined"
											<br/>undefined :是一个表示"无"的原始值或者说表示"缺少值"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined； 
    										<br/>例如变量被声明了，但没有赋值时，就等于undefined
    										<br/>typeof null
    										<br/>//"object"
    										<br/>null : 是一个对象(空对象, 没有任何属性和方法)；
    										<br/>例如作为函数的参数，表示该函数的参数不是对象；
										</pre>						
									</p>
								</li>
								<li>
									<h3>写一个通用的事件侦听器函数。</h3>
									<p>
										<pre>
											// event(事件)工具集，来源：github.com/markyun
										    markyun.Event = {
										        // 页面加载完成后
										        readyEvent : function(fn) {
										            if (fn==null) {
										                fn=document;
										            }
										            var oldonload = window.onload;
										            if (typeof window.onload != 'function') {
										                window.onload = fn;
										            } else {
										                window.onload = function() {
										                    oldonload();
										                    fn();
										                };
										            }
										        },
										        // 视能力分别使用dom0||dom2||IE方式 来绑定事件
										        // 参数： 操作的元素,事件名称 ,事件处理程序
										        addEvent : function(element, type, handler) {
										            if (element.addEventListener) {
										                //事件类型、需要执行的函数、是否捕捉
										                element.addEventListener(type, handler, false);
										            } else if (element.attachEvent) {
										                element.attachEvent('on' + type, function() {
										                    handler.call(element);
										                });
										            } else {
										                element['on' + type] = handler;
										            }
										        },
										        // 移除事件
										        removeEvent : function(element, type, handler) {
										            if (element.removeEventListener) {
										                element.removeEventListener(type, handler, false);
										            } else if (element.datachEvent) {
										                element.detachEvent('on' + type, handler);
										            } else {
										                element['on' + type] = null;
										            }
										        },
										        // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
										        stopPropagation : function(ev) {
										            if (ev.stopPropagation) {
										                ev.stopPropagation();
										            } else {
										                ev.cancelBubble = true;
										            }
										        },
										        // 取消事件的默认行为
										        preventDefault : function(event) {
										            if (event.preventDefault) {
										                event.preventDefault();
										            } else {
										                event.returnValue = false;
										            }
										        },
										        // 获取事件目标
										        getTarget : function(event) {
										            return event.target || event.srcElement;
										        },
										        // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
										        getEvent : function(e) {
										            var ev = e || window.event;
										            if (!ev) {
										                var c = this.getEvent.caller;
										                while (c) {
										                    ev = c.arguments[0];
										                    if (ev && Event == ev.constructor) {
										                        break;
										                    }
										                    c = c.caller;
										                }
										            }
										            return ev;
										        }
										    };
										</pre>
									</p>
								</li>
							</ol>
						</div>
						<div id="CSS">
							<h2>CSS</h2>
							<ol>
								<li>
									<h3>["1", "2", "3"].map(parseInt) 答案是多少？</h3>
									<p>
										[1, NaN, NaN] 因为 parseInt 需要两个参数 (val, radix)，
 										其中 radix 表示解析时用的基数。
 										map 传了 3 个 (element, index, array)，对应的 radix 不合法导致解析失败。
									</p>
								</li>
								<li>
									<h3>事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3>
									<p>
										<br/>1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。
 										<br/>2. 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；
 										<br/>3. ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）
									</p>
								</li>
								<li>
									<h3>什么是闭包（closure），为什么要用它？</h3>
									<p>
										闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。
										<br/>闭包的特性：
										<br/>1.函数内再嵌套函数
										<br/>2.内部函数可以引用外层的参数和变量
										<br/>3.参数和变量不会被垃圾回收机制回收
										<pre>
											//li节点的onclick事件都能正确的弹出当前被点击的li索引
											 <ul id="testUL">
											    <li> index = 0</li>
											    <li> index = 1</li>
											    <li> index = 2</li>
											    <li> index = 3</li>
											</ul>
											    var nodes = document.getElementsByTagName("li");
											    for(i = 0;i<nodes.length;i+= 1){
											        nodes[i].onclick = function(){
											            console.log(i+1);//不用闭包的话，值每次都是4
											        }(i);
											    }
										</pre>
										<br/>执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在
										<br/>使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源
										<br/>因为say667()的内部函数的执行需要依赖say667()中的变量
										<br/>这是对闭包作用的非常直白的描述
										<pre>
											function say667() {
										    // Local variable that ends up within closure
										    var num = 666;
										    var sayAlert = function() {
										        alert(num);
										    }
										    num++;
										    return sayAlert;
										}
										 var sayAlert = say667();
										 sayAlert()//执行结果应该弹出的667
										</pre>
									</p>
								</li>
								<li>
									<h3>javascript 代码中的"use strict";是什么意思 ? 使用它区别是什么？</h3>
									<p>
										use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,
										<br/>使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。
										<br/>默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;
										<br/>全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；
										<br/>消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;
										<br/>提高编译器效率，增加运行速度；
										<br/>为未来新版本的Javascript标准化做铺垫。
									</p>
								</li>
								<li>
									<h3>new操作符具体干了什么呢?</h3>
									<p>
										<br/>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
    					 				<br/>2、属性和方法被加入到 this 引用的对象中。
     									<br/>3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。
     									<pre>
     										var obj  = {};
											obj.__proto__ = Base.prototype;
											Base.call(obj);
     									</pre>
									</p>
								</li>
								<li>
									<h3>Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</h3>
									<p>
										hasOwnProperty
										<br/>javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。
										<br/>使用方法：
										<br/>object.hasOwnProperty(proName)
										<br/>其中参数object是必选项。一个对象的实例。
										<br/>proName是必选项。一个属性名称的字符串值。
										<br/>如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。
									</p>
								</li>
								<li>
									<h3>什么是外边距重叠？重叠的结果是什么？</h3>
									<p>
										外边距重叠就是margin-collapse。
										<br/> 在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。
										<br/> 折叠结果遵循下列计算规则：
										<br/> 1.两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。
										<br/> 2.两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。
										<br/> 3.两个外边距一正一负时，折叠结果是两者的相加的和。
										<br/>
									</p>
								</li>
								<li>
									<h3>rgba()和opacity的透明效果有什么不同？</h3>
									<p>rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度，
										<br/> 而rgba()只作用于元素的颜色或其背景色。（设置rgba透明的元素的子元素不会继承透明效果！）
										<br/>
									</p>
								</li>
								<li>
									<h3>css中可以让文字在垂直和水平方向上重叠的两个属性是什么？</h3>
									<p>
										垂直方向：line-height
										<br/> 水平方向：letter-spacing
										<br/> 那么问题来了，关于letter-spacing的妙用知道有哪些么？
										<br/> 答案:可以用于消除inline-block元素间的换行符空格间隙问题。
										<br/>
									</p>
								</li>
								<li>
									<h3>
								如何垂直居中一个浮动元素？
							</h3>
									<p>
										<pre>
// 方法一：已知元素的高宽   
#div1{   
    background-color:#6699FF;   
    width:200px;   
    height:200px;   
  
    position: absolute;        //父元素需要相对定位   
    top: 50%;   
    left: 50%;   
    margin-top:-100px ;   //二分之一的height，width  
    margin-left: -100px;   
    }   
//方法二:未知元素的高宽   
  #div1{   
    width: 200px;   
    height: 200px;   
    background-color: #6699FF;   
    margin:auto;   
    position: absolute;        //父元素需要相对定位   
    left: 0;   
    top: 0;   
    rightright: 0;   
    bottombottom: 0;   
    }  
								</pre> 那么问题来了，如何垂直居中一个
										<img>?（用更简便的方法。）
										<pre>
//&lt;img&gt;的容器设置如下   	
#container     
display:table-cell;   
text-align:center;   
vertical-align:middle;   
								</pre>
									</p>
								</li>
								<li>
									<h3>
								px和em的区别。 
							</h3>
									<p>
										px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。
										<br/> 　　 浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。
									</p>
								</li>
								<li>
									<h3>
								描述一个"reset"的CSS文件并如何使用它。知道normalize.css吗？你了解他们的不同之处？
							</h3>
									<p>
										重置样式非常多，凡是一个前端开发人员肯定有一个常用的重置CSS文件并知道如何使用它们。他们是盲目的在做还是知道为什么这么做呢？原因是不同的浏览器对一些元素有不同的默认样式，如果你不处理，在不同的浏览器下会存在必要的风险，或者更有戏剧性的性发生。
										<br/> 　　 你可能会用Normalize来代替你的重置样式文件。它没有重置所有的样式风格，但仅提供了一套合理的默认样式值。既能让众多浏览器达到一致和合理，但又不扰乱其他的东西（如粗体的标题）。
										<br/> 在这一方面，无法做每一个复位重置。它也确实有些超过一个重置，它处理了你永远都不用考虑的怪癖，像HTML的audio元素不一致或line-height不一致。
									</p>
								</li>
								<li>
									<h3>
								Sass、LESS是什么？大家为什么要使用他们？ 
							</h3>
									<p>
										他们是CSS预处理器。他是CSS上的一种抽象层。他们是一种特殊的语法/语言编译成CSS。
										<br/> 　　例如Less是一种动态样式语言. 将CSS赋予了动态语言的特性，如变量，继承，运算， 函数. LESS 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可一在服务端运行 (借助 Node.js)。
										<br/> 为什么要使用它们？
										<br/> •结构清晰，便于扩展。
										<br/> •可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对浏览器语法差异的重复处理，减少无意义的机械劳动。
										<br/> •可以轻松实现多重继承。
										<br/> •完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。
										<br/>
									</p>
								</li>
								<li>
									<h3>
								display:none与visibility:hidden的区别是什么？ 
							</h3>
									<p>
										•display : 隐藏对应的元素但不挤占该元素原来的空间。
										<br/> •visibility: 隐藏对应的元素并且挤占该元素原来的空间。
										<br/> 　　 即是，使用CSS display:none属性后，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”;而使用visibility:hidden属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在。
										<br/>
									</p>
								</li>
						</div>
					</div>
					</ol>
				</div>
				<div class="col-xs-12 col-md-3 side">
					<div class="catalog" style="width: 150px;">
						<h3>目录</h3>
						<ul>
							<li><a href="#Html">JavaScript</a></li>
							<li><a href="#CSS">CSS</a></li>
						</ul>
					</div>
				</div>
			</div>
			<!--正文-->
		</div>
	</body>

</html>